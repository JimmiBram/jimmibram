<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hej, jeg hedder Jimmi, hvad hedder du?</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            /* Deep, almost-black nebula-like background */
            background: radial-gradient(circle at 50% 20%, rgba(30,30,60,0.3) 0%, rgba(10,10,25,0.9) 60%, #060611 100%);
            overflow: hidden;
            cursor: none; /* Hide default cursor */
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Orbitron', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        .linkedin-icon {
          position: fixed;
          bottom: 20px;
          left: 20px;
          z-index: 10;
          animation: float 3s ease-in-out infinite;
          filter: drop-shadow(0 0 8px rgba(10, 102, 194, 0.6));
          transition: filter 0.3s, transform 0.3s;
        }
        
        .linkedin-icon svg {
          opacity: 0.85;
          transition: opacity 0.3s;
        }
        
        .linkedin-icon:hover {
          filter: drop-shadow(0 0 12px rgba(10, 102, 194, 0.8));
          transform: scale(1.1) translateY(-5px);
        }
        
        .linkedin-icon:hover svg {
          opacity: 1;
        }
        
        .email-icon {
          position: fixed;
          bottom: 20px;
          left: 83px; 
          z-index: 10;
          animation: float 3s 0.2s ease-in-out infinite;
          filter: drop-shadow(0 0 6px rgba(200, 200, 200, 0.5));
          transition: filter 0.3s, transform 0.3s;
        }
        
        .email-icon svg {
          opacity: 0.85;
          transition: opacity 0.3s;
          stroke: #d0d0d0;
          stroke-width: 2;
          fill: none; /* Outline style */
        }
        
        .email-icon:hover {
          filter: drop-shadow(0 0 10px rgba(220, 220, 220, 0.7));
          transform: scale(1.1) translateY(-5px);
        }
        
        .email-icon:hover svg {
          opacity: 1;
        }

        /* Custom crosshair cursor */
        #cursorCrosshair {
          position: fixed;
          top: 0;
          left: 0;
          width: 28px;
          height: 28px;
          pointer-events: none;
          z-index: 10000;
          transform: translate(-50%, -50%);
          opacity: 0; /* Start hidden */
          transition: opacity 0.5s ease;
        }
        #cursorCrosshair::before,
        #cursorCrosshair::after {
          content: "";
          position: absolute;
          background: #ffffff;
        }
        /* vertical line */
        #cursorCrosshair::before {
          width: 2px;
          height: 100%;
          left: 50%;
          top: 0;
          transform: translateX(-50%);
        }
        /* horizontal line */
        #cursorCrosshair::after {
          height: 2px;
          width: 100%;
          top: 50%;
          left: 0;
          transform: translateY(-50%);
        }

        /* Mobile-specific styles */
        @media (hover: none) {
          #cursorCrosshair {
            width: 40px; /* Larger on mobile */
            height: 40px;
          }
          #cursorCrosshair::before,
          #cursorCrosshair::after {
            background: rgba(255, 255, 255, 0.8);
          }
          #cursorCrosshair::before {
            width: 3px;
          }
          #cursorCrosshair::after {
            height: 3px;
          }
        }

        /* Ammo (brain) display */
        .ammo-container {
          position: fixed;
          bottom: 20px;
          right: 20px;
          display: flex;
          gap: 6px;
          z-index: 10001;
          pointer-events: none; /* allow clicks to pass through */
        }
        .ammo-slot {
          width: 18px;
          height: 18px;
          border-radius: 50%;
          background: #ff66cc; /* vibrant color */
          box-shadow: 0 0 3px rgba(255,255,255,0.6);
          transition: transform 0.3s ease, opacity 0.3s ease;
        }
        .ammo-slot.used {
           opacity: 0.25;
           transform: scale(0.5);
        }

        /* Flash animation for LinkedIn icon when out of ammo */
        @keyframes flash {
          0% { filter: brightness(1); }
          50% { filter: brightness(2) drop-shadow(0 0 6px rgba(255,255,255,0.9)); }
          100% { filter: brightness(1); }
        }
        .linkedin-icon.flash {
          animation: flash 0.4s ease;
        }

        /* Firework particles */
        .fireworkParticle {
          position: fixed;
          width: 14px;
          height: 14px;
          border-radius: 50%;
          pointer-events: none;
          animation: fireAnim 0.6s ease-out forwards;
        }
        @keyframes fireAnim {
          0% { transform: translate(0,0) scale(1); opacity:1; }
          100% { transform: translate(var(--dx), var(--dy)) scale(0.3); opacity:0; }
        }
    </style>
</head>
<body>
    <canvas id="bubbleCanvas"></canvas>
    <div id="cursorCrosshair"></div>
    <div id="ammoContainer" class="ammo-container"></div>
    <a href="https://www.linkedin.com/in/jimmibram/" class="linkedin-icon" target="_blank" rel="noopener noreferrer">
      <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="#0A66C2">
        <path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"/>
      </svg>
    </a>
    <a href="mailto:hej@jimmibram.dk" class="email-icon" title="Send Email">
      <!-- Modern minimalist envelope icon -->
      <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
        <rect x="2.5" y="5" width="19" height="14" rx="2" ry="2"/>
        <polyline points="3,6 12,13 21,6"/>
      </svg>
    </a>
    <script>
        const canvas = document.getElementById('bubbleCanvas');
        const ctx = canvas.getContext('2d');
        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;

        const phrases = [
            "Hvad er software i 2025?",
            "Hvordan rådgiver man i en foranderlig verden?",
            "Hvad skal de næste generationer lære?",
            "Hvad er en udvikler i 2026?",
            "Hvordan forstærker AI mine kompetencer?",
            "Er manuel software test stadig nødvendigt?",
            "Hvordan får vi junior udviklerne i gang?",
            "Hvad med sikkerheden når AI udvikler?"
        ];

        const baseColors = [
            '#202060', // Dark Indigo
            '#602080', // Purple
            '#b030b0', // Magenta/Fuchsia
            '#6c91bf', // Steel Blue
            '#5bc8af'  // Medium Aquamarine
        ];

        const bubbles = [];
        const maxBubbles = 20;
        let bubbleIdCounter = 0;
        let childSpawnCount = 0; // Track how many bubbles have spawned children

        // --- Explosion Particles ---
        const particles = [];

        // --- Ammo system ---
        let ammo = 10;
        const ammoContainer = document.getElementById('ammoContainer');
        const fireworksIcon = document.querySelector('.email-icon');

        function initAmmo() {
          ammoContainer.innerHTML = '';
          for (let i = 0; i < 10; i++) {
            const slot = document.createElement('div');
            slot.className = 'ammo-slot';
            ammoContainer.appendChild(slot);
          }
        }

        initAmmo();

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                // Random velocity
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 3;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.radius = 3 + Math.random() * 3;
                this.life = 0;
                this.maxLife = 0.6 + Math.random() * 0.4; // seconds
                this.opacity = 1;
                this.color = color; // expects `rgb(r,g,b)` string
            }

            update(dt) {
                this.life += dt;
                // Simple physics
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.5 * dt; // slight gravity
                // Fade and shrink
                this.opacity = 1 - this.life / this.maxLife;
                this.radius *= 0.96;
            }

            draw(ctx) {
                if (this.opacity <= 0 || this.radius <= 0) return;
                ctx.fillStyle = this.color.replace('rgb', 'rgba').replace(')', `, ${this.opacity})`);
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function explodeBubble(index) {
            const bubble = bubbles[index];
            // Generate particles using bubble base color (brighter)
            const { r, g, b } = bubble.baseRgbColor;
            const brightR = Math.min(255, r + 80);
            const brightG = Math.min(255, g + 80);
            const brightB = Math.min(255, b + 80);
            const baseColorStr = `rgb(${brightR}, ${brightG}, ${brightB})`;

            const particleCount = 12;
            for (let i = 0; i < particleCount; i++) {
                particles.push(new Particle(bubble.x, bubble.y, baseColorStr));
            }

            // Remove the bubble immediately
            bubbles.splice(index, 1);
        }

        // Click handler to detect bubble click
        canvas.addEventListener('click', (e) => {
            if (ammo <= 0) {
                triggerFireworks();
                if (isMobile) {
                    cursorEl.style.opacity = '0'; // Hide crosshair when out of ammo
                }
                return; // no ammo, show fireworks
            }

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            let hit=false;
            for (let i = bubbles.length - 1; i >= 0; i--) {
                const b = bubbles[i];
                const dx = x - b.x;
                const dy = y - b.y;
                if (dx * dx + dy * dy <= b.radius * b.radius) {
                    explodeBubble(i);
                    hit=true;
                    break;
                }
            }

            // use ammo regardless of hit/miss
            if (ammo > 0) {
                ammo--;
                const slots = ammoContainer.querySelectorAll('.ammo-slot');
                if (slots[ammo]) {
                    slots[ammo].classList.add('used');
                }
            }

            if(!hit){createPoof(x,y);}
        });

        // Add touch handling for mobile
        if (isMobile) {
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Prevent default touch behavior
                if (ammo <= 0) {
                    triggerFireworks();
                    cursorEl.style.opacity = '0'; // Hide crosshair when out of ammo
                    return;
                }

                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;

                // Move crosshair to touch position
                cursorEl.style.left = `${touch.clientX}px`;
                cursorEl.style.top = `${touch.clientY}px`;

                let hit=false;
                for (let i = bubbles.length - 1; i >= 0; i--) {
                    const b = bubbles[i];
                    const dx = x - b.x;
                    const dy = y - b.y;
                    if (dx * dx + dy * dy <= b.radius * b.radius) {
                        explodeBubble(i);
                        hit=true;
                        break;
                    }
                }

                // use ammo regardless of hit/miss
                if (ammo > 0) {
                    ammo--;
                    const slots = ammoContainer.querySelectorAll('.ammo-slot');
                    if (slots[ammo]) {
                        slots[ammo].classList.add('used');
                    }
                }

                if(!hit){createPoof(x,y);}
            });
        }

        // --- Helper Function: Hex to RGB ---
        function hexToRgb(hex) {
            let bigint = parseInt(hex.slice(1), 16);
            let r = (bigint >> 16) & 255;
            let g = (bigint >> 8) & 255;
            let b = bigint & 255;
            return { r, g, b };
        }

        // --- Phrase Manager ---
        const phraseManager = (() => {
            const maxRecent = 5;
            let recentlyUsedIndices = [];

            return {
                getNextPhrase: () => {
                    const availableIndices = phrases
                        .map((_, index) => index)
                        .filter(index => !recentlyUsedIndices.includes(index));

                    let selectedIndex;
                    if (availableIndices.length > 0) {
                        // Select from available (unused) indices
                        selectedIndex = availableIndices[Math.floor(Math.random() * availableIndices.length)];
                    } else {
                        // All phrases used recently, pick any random one
                        selectedIndex = Math.floor(Math.random() * phrases.length);
                    }

                    // Update recently used queue
                    recentlyUsedIndices.push(selectedIndex);
                    if (recentlyUsedIndices.length > maxRecent) {
                        recentlyUsedIndices.shift(); // Remove the oldest index
                    }

                    return phrases[selectedIndex];
                }
            };
        })();

        // --- Bubble Class ---
        class Bubble {
            constructor(x, y, radius, text, parent = null) {
                this.id = bubbleIdCounter++;
                this.x = x;
                this.y = y;
                this.targetRadius = radius;
                this.radius = parent ? 0 : radius * 0.1; // Start small if child
                this.text = text;
                this.parent = parent;
                this.children = [];

                // --- Color Selection ---
                this.baseHexColor = baseColors[Math.floor(Math.random() * baseColors.length)];
                this.baseRgbColor = hexToRgb(this.baseHexColor);

                // Text Color (calculate a contrasting light color)
                // Simple brightness check for contrast
                const brightness = (this.baseRgbColor.r * 299 + this.baseRgbColor.g * 587 + this.baseRgbColor.b * 114) / 1000;
                this.textColor = brightness > 128 ? 'rgba(0, 0, 0, 0.9)' : 'rgba(255, 255, 255, 0.9)';

                // Movement
                this.vx = parent ? parent.vx + (Math.random() - 0.5) * 1 : (Math.random() - 0.5) * 2; // Inherit some velocity
                this.vy = parent ? parent.vy + (Math.random() - 0.5) * 1 : (Math.random() - 0.5) * 2;
                this.targetX = x; // Target for drifting
                this.targetY = y; // Target for drifting
                this.setNewTarget();

                // State Management
                this.state = 'growing'; // growing, drifting, splitting_start, splitting, fading
                this.life = 0;
                this.maxLife = 8 + Math.random() * 4; // seconds
                // Adjust splitTime based on childSpawnCount
                this.splitTime = childSpawnCount < 2 ? 3 : this.maxLife * (0.6 + Math.random() * 0.2); // Split around 60-80% of life for normal bubbles, 3 seconds for first two
                this.splitDuration = 0.6; // seconds for the split animation
                this.splitProgress = 0;
                this.opacity = parent ? 0 : 1; // Start transparent if child, fade in during grow
                this.targetOpacity = 1;
            }

            calculateRequiredRadiusForText() {
                // Don't calculate if radius is tiny
                if (this.radius < 5) return this.radius;

                // 1. Determine font size based on *current* radius
                let fontSize = Math.max(8, Math.min(20, this.radius / 3.8));
                ctx.font = `bold ${fontSize}px 'Orbitron', sans-serif`;

                // 2. Wrap text based on current radius estimate
                const words = this.text.split(' ');
                let line = '';
                const lines = [];
                const maxWidth = this.radius * 1.3; // Use the same factor as drawText
                let maxLineWidth = 0;

                for (let n = 0; n < words.length; n++) {
                    const testLine = line + words[n] + ' ';
                    const metrics = ctx.measureText(testLine);
                    const testWidth = metrics.width;
                    if (testWidth > maxWidth && n > 0) {
                        lines.push(line);
                        maxLineWidth = Math.max(maxLineWidth, ctx.measureText(line).width);
                        line = words[n] + ' ';
                    } else {
                        line = testLine;
                    }
                }
                lines.push(line);
                maxLineWidth = Math.max(maxLineWidth, ctx.measureText(line).width);

                // 3. Calculate text block dimensions
                const lineHeight = fontSize * 1.2;
                const totalTextHeight = lines.length * lineHeight;
                const totalTextWidth = maxLineWidth;

                // 4. Calculate required radius (diagonal / 2 + margin)
                // Calculate distance from center to corner of text box
                const halfWidth = totalTextWidth / 2;
                const halfHeight = totalTextHeight / 2;
                const distToCorner = Math.sqrt(halfWidth * halfWidth + halfHeight * halfHeight);

                // Add margin (e.g., 30% larger than text bounds)
                const requiredRadius = distToCorner * 1.3;

                // Return the larger of current target or required, with a minimum size
                return Math.max(20, requiredRadius); // Ensure a minimum bubble size
            }

            setNewTarget() {
                // Set a new random target position within bounds for drifting
                const margin = this.targetRadius * 1.5;
                this.targetX = Math.random() * (width - 2 * margin) + margin;
                this.targetY = Math.random() * (height - 2 * margin) + margin;
            }

            update(deltaTime) {
                this.life += deltaTime;

                // State transitions & updates
                if (this.state === 'growing') {
                    this.radius += (this.targetRadius - this.radius) * 0.15; // Faster growth
                    this.opacity += (this.targetOpacity - this.opacity) * 0.1; // Fade in

                    // Continuously check and update target radius if text needs more space
                    const requiredRadius = this.calculateRequiredRadiusForText();
                    if (requiredRadius > this.targetRadius) {
                        this.targetRadius = requiredRadius;
                    }

                    // Transition to drifting when close enough to the target radius
                    if (Math.abs(this.targetRadius - this.radius) < 1) {
                        this.radius = this.targetRadius;
                        this.opacity = this.targetOpacity;
                        this.state = 'drifting';
                    }

                    if (this.life > this.splitTime && bubbles.length < maxBubbles - 1 && this.children.length === 0) { // Ensure space & not already split
                       this.state = 'splitting_start';
                       this.splitProgress = 0;
                    } else if (this.life > this.maxLife) {
                         this.state = 'fading';
                         this.targetOpacity = 0; // Start fade out
                    }

                } else if (this.state === 'drifting') {
                    // Move towards target
                    const dx = this.targetX - this.x;
                    const dy = this.targetY - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    const moveSpeed = 0.8 + (this.targetRadius / 150); // Slightly faster drift
                    if (dist > 1) { // Avoid division by zero/jitter
                        this.vx += (dx / dist) * moveSpeed * 0.1;
                        this.vy += (dy / dist) * moveSpeed * 0.1;
                    }

                    // Apply friction/damping
                    this.vx *= 0.97;
                    this.vy *= 0.97;

                    this.x += this.vx;
                    this.y += this.vy;

                    // If close to target, set a new one
                    if (dist < this.targetRadius * 0.3) {
                        this.setNewTarget();
                    }

                    // Check if it's time to split
                    if (this.life > this.splitTime && bubbles.length < maxBubbles - 1 && this.children.length === 0) { // Ensure space & not already split
                       this.state = 'splitting_start';
                       this.splitProgress = 0;
                    } else if (this.life > this.maxLife) {
                         this.state = 'fading';
                         this.targetOpacity = 0; // Start fade out
                    }

                } else if (this.state === 'splitting_start') {
                     // Spawn children immediately
                     if (this.spawnChildren()) { // Only proceed if children were actually spawned
                         this.state = 'splitting';
                         this.targetOpacity = 0; // Parent starts fading during split
                     } else {
                         // Couldn't spawn (max limit reached), go back to drifting or start fading
                         this.state = this.life > this.maxLife ? 'fading' : 'drifting';
                     }

                } else if (this.state === 'splitting') {
                     this.splitProgress += deltaTime / this.splitDuration;
                     // Parent shrinks and fades during split
                     const easeOutQuad = t => t * (2 - t);
                     const progressEased = easeOutQuad(this.splitProgress);

                     this.radius = this.targetRadius * (1 - progressEased); // Shrink parent
                     this.opacity += (this.targetOpacity - this.opacity) * 0.1; // Fade out parent

                     if (this.splitProgress >= 1) {
                         this.radius = 0; // Ensure parent is gone visually
                         this.opacity = 0;
                         this.state = 'fading'; // Transition to final state
                     }
                     // Children handle their own growth/fade in

                } else if (this.state === 'fading') {
                     this.radius *= 0.95; // Continue shrinking
                     this.opacity += (this.targetOpacity - this.opacity) * 0.05; // Fade towards target (usually 0)
                     if (this.radius < 1 || this.opacity < 0.01) {
                         this.radius = 0;
                         this.opacity = 0;
                         // Marked for removal in main loop
                     }
                }

                // Keep within bounds (gentle push back)
                const pushForce = 0.1;
                if (this.x < this.radius) { this.vx += pushForce; this.x = this.radius; }
                if (this.x > width - this.radius) { this.vx -= pushForce; this.x = width - this.radius; }
                if (this.y < this.radius) { this.vy += pushForce; this.y = this.radius; }
                if (this.y > height - this.radius) { this.vy -= pushForce; this.y = height - this.radius; }
            }

            spawnChildren() {
                 if (bubbles.length >= maxBubbles - 1) {
                     console.log('Max bubbles reached, cannot spawn children.');
                     return false; // Indicate failure
                 }

                 const angleOffset = Math.random() * Math.PI * 2; // Random start direction
                 for (let i = 0; i < 2; i++) {
                     const angle = angleOffset + i * Math.PI; // Spawn 180 degrees apart
                     const childRadius = this.targetRadius * (0.5 + Math.random() * 0.2); // 50-70% of parent size
                     // Start exactly at parent center for sticky effect
                     const childX = this.x; 
                     const childY = this.y;
                     const childText = phraseManager.getNextPhrase(); // Use the manager

                     const child = new Bubble(childX, childY, childRadius, childText, this);
                     // Give initial outward velocity relative to parent
                     const speedBoost = 4 + Math.random() * 2;
                     child.vx = this.vx + Math.cos(angle) * speedBoost;
                     child.vy = this.vy + Math.sin(angle) * speedBoost;
                     child.state = 'growing'; // Start child in growing state
                     child.opacity = 0; // Start child transparent
                     child.radius = 0; // Start child tiny

                     bubbles.push(child);
                     this.children.push(child);
                 }
                 childSpawnCount++; // Increment the counter when children are spawned
                 console.log(`Spawned children for bubble ${this.id}. Total bubbles: ${bubbles.length}`);
                 return true; // Indicate success
            }

            draw() {
                if (this.radius <= 0.1 || this.opacity <= 0.01) return;

                // --- Draw the main visible bubble with a gradient --- 
                const { r, g, b } = this.baseRgbColor;

                // Create radial gradient (center lighter, edge darker)
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);

                // Center color (lighter, slightly less saturated)
                const centerR = Math.min(255, r + 60);
                const centerG = Math.min(255, g + 60);
                const centerB = Math.min(255, b + 60);
                gradient.addColorStop(0, `rgba(${centerR}, ${centerG}, ${centerB}, ${this.opacity * 0.9})`);

                // Mid color (close to original)
                gradient.addColorStop(0.7, `rgba(${r}, ${g}, ${b}, ${this.opacity * 0.75})`);

                // Edge color (darker)
                const edgeR = Math.max(0, r - 50);
                const edgeG = Math.max(0, g - 50);
                const edgeB = Math.max(0, b - 50);
                gradient.addColorStop(1, `rgba(${edgeR}, ${edgeG}, ${edgeB}, ${this.opacity * 0.7})`);

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // --- Text Drawing ---
                if (this.radius > 10 && this.opacity > 0.1) {
                   this.drawText();
                }
            }

             // Separate drawing function for the metaball effect layer
             drawMetaballLayer() {
                 if (this.radius <= 0.1 || this.opacity <= 0.01) return;

                 // Draw slightly larger for the blur effect.
                 const metaballRadius = this.radius * 1.4;
                  
                 // Calculate a bright version of the base color for the glow layer
                 const { r, g, b } = this.baseRgbColor;
                 const glowR = Math.min(255, r + 100);
                 const glowG = Math.min(255, g + 100);
                 const glowB = Math.min(255, b + 100);
                 // Use RGB for the metaball layer (no alpha needed before filters)
                 ctx.fillStyle = `rgb(${glowR}, ${glowG}, ${glowB})`; 

                 ctx.beginPath();
                 ctx.arc(this.x, this.y, metaballRadius, 0, Math.PI * 2);
                 ctx.fill();
             }

            drawText() {
                const maxTextWidth = this.radius * 1.6; // Allow text slightly wider than radius
                let fontSize = Math.max(8, Math.min(20, this.radius / 3.8)); 

                ctx.font = `bold ${fontSize}px 'Orbitron', sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                // Adjust text opacity based on bubble opacity, but keep it readable
                const textOpacity = Math.min(1, this.opacity * 1.5);
                // Ensure text color uses the calculated opacity
                if (this.textColor.startsWith('rgba')) {
                   ctx.fillStyle = this.textColor.replace(/,[^,]+$/, `, ${textOpacity})`);
                } else {
                    // Fallback if textColor wasn't calculated as rgba
                    ctx.fillStyle = `rgba(255, 255, 255, ${textOpacity})`; 
                }

                // Basic word wrapping
                const words = this.text.split(' ');
                let line = '';
                const lines = [];
                const maxWidth = this.radius * 1.3; // Further reduced max width for more margin
                const lineHeight = fontSize * 1.2;

                for (let n = 0; n < words.length; n++) {
                    const testLine = line + words[n] + ' ';
                    const metrics = ctx.measureText(testLine);
                    const testWidth = metrics.width;
                    if (testWidth > maxWidth && n > 0) {
                        lines.push(line);
                        line = words[n] + ' ';
                    } else {
                        line = testLine;
                    }
                }
                lines.push(line);

                const totalTextHeight = lines.length * lineHeight;
                let startY = this.y - totalTextHeight / 2 + lineHeight / 2;

                // Adjust font size if text block is too tall for the bubble radius
                if (totalTextHeight > this.radius * 1.3) { // Further reduced allowed height for more margin
                    fontSize *= (this.radius * 1.3) / totalTextHeight;
                    // Re-check minimum font size
                    fontSize = Math.max(8, fontSize);
                    ctx.font = `bold ${fontSize}px 'Orbitron', sans-serif`;
                     // Recalculate line height and startY
                     const newLineHeight = fontSize * 1.2;
                     const newTotalTextHeight = lines.length * newLineHeight;
                     startY = this.y - newTotalTextHeight / 2 + newLineHeight / 2;
                }

                // Draw the lines of text
                lines.forEach((l, index) => {
                    // Prevent text overflowing vertically if many lines
                    // Use the tighter margin calculation here too
                    ctx.fillText(l.trim(), this.x, startY + index * lineHeight);
                });
            }
        }

        // --- Animation Loop ---
        let lastTime = 0;
        function animate(timestamp) {
            const deltaTime = Math.min(0.05, (timestamp - lastTime) / 1000 || 0); // time in seconds, capped delta
            lastTime = timestamp;

            ctx.clearRect(0, 0, width, height);

            // Spawn initial bubble if needed
            if (bubbles.length === 0) {
                 console.log('No bubbles, creating initial one.');
                 const initialRadius = Math.min(width, height) * 0.16; // Make initial bubble larger
                 bubbles.push(new Bubble(width / 2, height / 2, initialRadius, phraseManager.getNextPhrase())); // Use the manager
                 bubbles[0].state = 'growing'; // Start first bubble growing
                 bubbles[0].opacity = 1; // Ensure first bubble is visible
            }


            // --- Update Bubbles ---
            for (let i = bubbles.length - 1; i >= 0; i--) {
                bubbles[i].update(deltaTime);
                // Remove faded/shrunken bubbles
                if (bubbles[i].radius <= 0.1 && bubbles[i].opacity <= 0.01) {
                    console.log(`Removing bubble ${bubbles[i].id}. Total bubbles: ${bubbles.length - 1}`);
                    bubbles.splice(i, 1);
                }
            }

            // --- Update & Draw Explosion Particles ---
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update(deltaTime);
                if (particles[i].life >= particles[i].maxLife) {
                    particles.splice(i, 1);
                }
            }

            // --- Draw Metaball Layer ---
            ctx.save();
            // Apply filters for metaball effect
            // Blur radius and contrast value are key to the effect's appearance
            ctx.filter = 'blur(18px) contrast(30)';
            // Optional: 'lighter' can make merges brighter
            // ctx.globalCompositeOperation = 'lighter'; 

            // Draw the shapes that will be merged by the filters
            // This needs to happen *before* restoring the context
            bubbles.forEach(bubble => {
                bubble.drawMetaballLayer();
            });

            // IMPORTANT: Draw a full canvas rect with the background color
            // AFTER drawing the white shapes but BEFORE restoring. This prevents
            // the white shapes bleeding to the edge due to the blur.
            ctx.globalCompositeOperation = 'destination-in';
            ctx.fillRect(0, 0, width, height);
            ctx.restore(); // Restore context state (removes filter for next draws)


            // --- Draw Bubbles and Text (On Top) ---
            // Use default composite operation
             ctx.globalCompositeOperation = 'source-over';
             bubbles.forEach(bubble => {
                 bubble.draw(); // Draws the main bubble and text
             });

            // Draw particles on top
            particles.forEach(p => p.draw(ctx));

            // // Optional: Display bubble count for debugging
            // ctx.fillStyle = 'white';
            // ctx.font = '14px Arial';
            // ctx.textAlign = 'left';
            // ctx.fillText(`Bubbles: ${bubbles.length}`, 10, 20);

            requestAnimationFrame(animate);
        }

        // --- Event Listeners ---
        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        });

        // Start animation
        console.log('Starting animation...');
        animate(0);

        // -- Custom cursor follow --
        const cursorEl = document.getElementById('cursorCrosshair');
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        if (isMobile) {
          // Center the crosshair on mobile
          cursorEl.style.left = '50%';
          cursorEl.style.top = '50%';
          
          // Show crosshair after 2 seconds
          setTimeout(() => {
            cursorEl.style.opacity = '1';
          }, 2000);
        } else {
          // Desktop behavior
          document.addEventListener('mousemove', (e) => {
            cursorEl.style.left = `${e.clientX}px`;
            cursorEl.style.top = `${e.clientY}px`;
            cursorEl.style.opacity = '1';
          });
        }

        function createPoof(x,y){
            const poofColor='rgba(200,200,200,1)';
            const count=8;
            for(let i=0;i<count;i++){
                particles.push(new Particle(x,y,poofColor));
            }
        }

        // Fireworks trigger when out of ammo
        function triggerFireworks(){
            if(!fireworksIcon) return;
            fireworksIcon.classList.add('flash');
            setTimeout(()=>fireworksIcon.classList.remove('flash'),400);

            const rect=fireworksIcon.getBoundingClientRect();
            const cx=rect.left+rect.width/2;
            const cy=rect.top+rect.height/2;
            const count=32;
            for(let i=0;i<count;i++){
                const part=document.createElement('div');
                part.className='fireworkParticle';
                const angle=Math.random()*Math.PI*2;
                const dist=60+Math.random()*40;
                const dx=Math.cos(angle)*dist;
                const dy=Math.sin(angle)*dist;
                part.style.setProperty('--dx',dx+'px');
                part.style.setProperty('--dy',dy+'px');
                part.style.left=cx+'px';
                part.style.top=cy+'px';
                part.style.background=`hsl(${Math.random()*360},80%,60%)`;
                document.body.appendChild(part);
                setTimeout(()=>part.remove(),600);
            }
        }

    </script>
</body>
</html>
