<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Space Travel</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      overflow: hidden;
      background-color: #000;
      width: 100vw;
      height: 100vh;
      position: relative;
      perspective: 500px;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    
    .stars {
      position: absolute;
      width: 100%;
      height: 100%;
    }
    
    .star {
      position: absolute;
      background-color: #fff;
      border-radius: 50%;
      z-index: 1;
    }
    
    .planet {
      position: absolute;
      border-radius: 50%;
      z-index: 2;
    }
    
    .flying-text {
      position: absolute;
      color: rgba(255, 255, 255, 0.95);
      font-weight: 700;
      z-index: 3;
      transform-style: preserve-3d;
      pointer-events: none;
      text-align: center;
      max-width: 300px;
      border-radius: 50%;
      word-wrap: break-word;
      padding: 40px; /* Increased padding for more margin */
      display: flex;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      backface-visibility: hidden; /* Prevent flickering during animation */
      will-change: transform, opacity, left, top; /* Optimize for animation */
      overflow: hidden;
      line-height: 1.4; /* Better line spacing */
      letter-spacing: 0.5px; /* Better readability */
      
      /* Create perfect circle */
      aspect-ratio: 1/1;
      
      /* Smooth transitions */
      transition: 
        background 0.5s ease-out,
        border 0.5s ease-out;
      
      /* More subtle glass/orb effect with reduced opacity */
      background: radial-gradient(
        circle at 30% 30%,
        rgba(255, 200, 100, 0.08) 0%,
        rgba(255, 120, 50, 0.06) 30%,
        rgba(255, 70, 20, 0.04) 60%,
        rgba(0, 0, 0, 0) 80%
      );
      
      /* More subtle shadow for 3D effect */
      box-shadow: 
        inset 0 0 20px rgba(255, 150, 0, 0.1),
        0 0 15px rgba(255, 100, 0, 0.08);
    }
    
    @keyframes flicker {
      0% { text-shadow: 0 0 4px rgba(255, 255, 255, 0.8), 0 0 8px rgba(255, 200, 50, 0.7), 0 0 12px rgba(255, 100, 20, 0.4), 0 0 16px rgba(255, 50, 0, 0.3); }
      33% { text-shadow: 0 0 4px rgba(255, 255, 255, 0.8), 0 0 10px rgba(255, 180, 30, 0.8), 0 0 14px rgba(255, 80, 10, 0.5), 0 0 18px rgba(255, 30, 0, 0.4); }
      66% { text-shadow: 0 0 4px rgba(255, 255, 255, 0.8), 0 0 6px rgba(255, 220, 70, 0.6), 0 0 10px rgba(255, 120, 30, 0.3), 0 0 14px rgba(255, 70, 0, 0.2); }
      100% { text-shadow: 0 0 4px rgba(255, 255, 255, 0.8), 0 0 8px rgba(255, 200, 50, 0.7), 0 0 12px rgba(255, 100, 20, 0.4), 0 0 16px rgba(255, 50, 0, 0.3); }
    }
    
    .linkedin-icon {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 10;
      animation: float 3s ease-in-out infinite;
      filter: drop-shadow(0 0 8px rgba(10, 102, 194, 0.6));
      transition: filter 0.3s, transform 0.3s;
    }
    
    .linkedin-icon svg {
      opacity: 0.85;
      transition: opacity 0.3s;
    }
    
    .linkedin-icon:hover {
      filter: drop-shadow(0 0 12px rgba(10, 102, 194, 0.8));
      transform: scale(1.1) translateY(-5px);
    }
    
    .linkedin-icon:hover svg {
      opacity: 1;
    }
    
    @keyframes float {
      0% {
        transform: translateY(0px);
      }
      50% {
        transform: translateY(-10px);
      }
      100% {
        transform: translateY(0px);
      }
    }
  </style>
</head>
<body>
  <div class="stars"></div>
  <a href="https://www.linkedin.com/in/jimmibram/" class="linkedin-icon" target="_blank" rel="noopener noreferrer">
    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="#0A66C2">
      <path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"/>
    </svg>
  </a>
  
  <script>
    const starsContainer = document.querySelector('.stars');
    const starCount = 200;
    const planetCount = 5;
    const maxDepth = 1000;
    
    // Danish phrases that will fly toward the viewer
    const phrases = [
      "Hvad er software i 2025?",
      "Hvordan rådgiver man i en foranderlig verden?",
      "Hvad skal de næste generationer lære?",
      "Hvad er en udvikler i 2026?"
    ];
    
    // Create stars
    for (let i = 0; i < starCount; i++) {
      createStar();
    }
    
    // Create planets
    for (let i = 0; i < planetCount; i++) {
      createPlanet();
    }
    
    // Create flying text elements
    phrases.forEach((phrase, index) => {
      setTimeout(() => {
        createFlyingText(phrase);
      }, index * 6000); // Stagger the appearance of each phrase by 6 seconds
    });
    
    // Set interval to continuously create new flying text
    setInterval(() => {
      const randomPhrase = phrases[Math.floor(Math.random() * phrases.length)];
      createFlyingText(randomPhrase);
    }, 8000); // Create a new phrase every 8 seconds to allow more reading time
    
    function createStar() {
      const star = document.createElement('div');
      star.className = 'star';
      
      // Random initial position
      const x = Math.random() * window.innerWidth - window.innerWidth / 2;
      const y = Math.random() * window.innerHeight - window.innerHeight / 2;
      const z = Math.random() * maxDepth;
      
      // Random brightness (opacity)
      const opacity = Math.random() * 0.8 + 0.2;
      
      // Set star properties
      star.style.opacity = opacity;
      
      // Store position data for animation
      star.dataset.x = x;
      star.dataset.y = y;
      star.dataset.z = z;
      star.dataset.speed = 0.2 + Math.random() * 0.8;
      
      updateStarPosition(star);
      
      starsContainer.appendChild(star);
    }
    
    function createPlanet() {
      const planet = document.createElement('div');
      planet.className = 'planet';
      
      // Random initial position
      const x = (Math.random() * 2 - 1) * window.innerWidth;
      const y = (Math.random() * 2 - 1) * window.innerHeight;
      const z = Math.random() * maxDepth + maxDepth * 0.5;
      
      // Generate random planet color
      const hue = Math.random() * 360;
      const saturation = 70 + Math.random() * 30;
      const lightness = 20 + Math.random() * 30;
      planet.style.backgroundColor = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
      
      // Random size
      const baseSize = 5 + Math.random() * 15;
      
      // Store position data for animation
      planet.dataset.x = x;
      planet.dataset.y = y;
      planet.dataset.z = z;
      planet.dataset.baseSize = baseSize;
      planet.dataset.speed = 0.2 + Math.random() * 0.3;
      
      updatePlanetPosition(planet);
      
      starsContainer.appendChild(planet);
    }
    
    function updateStarPosition(star) {
      const x = parseFloat(star.dataset.x);
      const y = parseFloat(star.dataset.y);
      const z = parseFloat(star.dataset.z);
      
      // Calculate perspective scale
      const scale = maxDepth / (z === 0 ? 0.1 : z);
      
      // Position with perspective
      star.style.left = `${x * scale + window.innerWidth / 2}px`;
      star.style.top = `${y * scale + window.innerHeight / 2}px`;
      
      // Size varies with distance
      const size = Math.max(0.5, 3 * scale / 5);
      star.style.width = `${size}px`;
      star.style.height = `${size}px`;
    }
    
    function updatePlanetPosition(planet) {
      const x = parseFloat(planet.dataset.x);
      const y = parseFloat(planet.dataset.y);
      const z = parseFloat(planet.dataset.z);
      const baseSize = parseFloat(planet.dataset.baseSize);
      
      // Calculate perspective scale
      const scale = maxDepth / (z === 0 ? 0.1 : z);
      
      // Position with perspective
      planet.style.left = `${x * scale + window.innerWidth / 2}px`;
      planet.style.top = `${y * scale + window.innerHeight / 2}px`;
      
      // Size varies with distance
      const size = Math.max(1, baseSize * scale / 3);
      planet.style.width = `${size}px`;
      planet.style.height = `${size}px`;
      
      // Add some shadow for 3D effect
      planet.style.boxShadow = `inset ${-size/5}px ${-size/8}px ${size/3}px rgba(0,0,0,0.8)`;
    }
    
    function createFlyingText(text) {
      const textElement = document.createElement('div');
      textElement.className = 'flying-text';
      
      // Simpler layout - use fewer lines to make text more readable
      // and prevent the squeeze effect
      const words = text.split(' ');
      
      // Format the text in 2-3 short lines to make it more compact and readable
      const wordsPerLine = Math.ceil(words.length / (words.length > 6 ? 3 : 2));
      let formattedText = '';
      
      for (let i = 0; i < words.length; i += wordsPerLine) {
        // Get a chunk of words for this line
        const line = words.slice(i, i + wordsPerLine).join(' ');
        formattedText += line + (i + wordsPerLine < words.length ? '<br>' : '');
      }
      
      // Set the formatted HTML
      textElement.innerHTML = formattedText;
      
      // Random initial position (far away) but more centered for smoother motion
      const x = (Math.random() * 0.6 - 0.3) * window.innerWidth; // Keep text more centered
      const y = (Math.random() * 0.6 - 0.3) * window.innerHeight; // Keep text more centered
      const z = maxDepth * 2.5; // Start far away
      
      // Text base color (orange/red hues for fire effect)
      const hue = 20 + Math.random() * 30; // 20-50 range (orange-red)
      const saturation = 90 + Math.random() * 10;
      const lightness = 70 + Math.random() * 20;
      textElement.style.color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
      
      // Add fire animation with slower pulsation
      const flickerSpeed = 1500 + Math.random() * 500; // 1500-2000ms range (much slower)
      textElement.style.animation = `flicker ${flickerSpeed}ms infinite`;
      
      // Base size calculation - consistent sizing
      const baseSize = 18 + Math.random() * 8; // Less random variation
      
      // Store position data for animation
      textElement.dataset.x = x;
      textElement.dataset.y = y;
      textElement.dataset.z = z;
      textElement.dataset.baseSize = baseSize;
      textElement.dataset.startTime = Date.now(); // Store creation time for smooth animation
      textElement.dataset.duration = 12000; // 12 seconds to travel through view
      
      // Fixed speed for smoother animation - no speed randomness
      textElement.dataset.speed = z / 300; // Consistent movement speed
      
      // Pre-compute size values to ensure consistency
      // These values are stored and used in updateFlyingTextPosition
      const textLength = textElement.innerText.length;
      textElement.dataset.aspectRatio = 1; // Perfect circle (width/height ratio)
      textElement.dataset.minSize = 90; // Increased minimum size (was 70)
      textElement.dataset.maxSize = 240; // Increased maximum size (was 200)
      
      // Adjust size based on text length - longer text gets larger orbs
      if (textLength > 30) {
        textElement.dataset.minSize = 110;
        textElement.dataset.maxSize = 280;
      }
      
      updateFlyingTextPosition(textElement);
      
      starsContainer.appendChild(textElement);
      
      // Remove the text element after it's traveled through view
      setTimeout(() => {
        if (textElement.parentNode) {
          // Fade out the element before removing it
          textElement.style.transition = 'opacity 1s ease-out';
          textElement.style.opacity = '0';
          
          // Actually remove after fade completes
          setTimeout(() => {
            if (textElement.parentNode) {
              textElement.parentNode.removeChild(textElement);
            }
          }, 1000);
        }
      }, 12000); // 12 seconds travel time + buffer
    }
    
    function updateFlyingTextPosition(textElement) {
      // Use time-based animation for smoother motion
      const startTime = parseFloat(textElement.dataset.startTime);
      const duration = parseFloat(textElement.dataset.duration);
      const now = Date.now();
      const elapsedTime = now - startTime;
      
      // Calculate progress as a percentage (0 to 1)
      const progress = Math.min(1, elapsedTime / duration);
      
      // Get initial position values
      const initialX = parseFloat(textElement.dataset.x);
      const initialY = parseFloat(textElement.dataset.y);
      const initialZ = parseFloat(textElement.dataset.z);
      
      // Calculate current Z position using easing for smooth deceleration
      // Use cubic ease-out for natural motion
      const easeOutCubic = t => 1 - Math.pow(1 - t, 3);
      
      // Calculate z position - start from initialZ and move to 0
      const z = initialZ * (1 - easeOutCubic(progress));
      
      // Update z position in dataset for other calculations
      textElement.dataset.z = z;
      
      // Calculate perspective scale
      // Prevent division by zero and clamp minimum scale
      const scale = Math.min(10, maxDepth / Math.max(50, z));
      
      // Adjust the 2D position to maintain trajectory
      // Add very slight movement on x and y axes for more natural motion
      const screenCenterX = window.innerWidth / 2;
      const screenCenterY = window.innerHeight / 2;
      
      // Size calculation - use stored min/max for consistency
      const minSize = parseFloat(textElement.dataset.minSize);
      const maxSize = parseFloat(textElement.dataset.maxSize);
      const baseSize = parseFloat(textElement.dataset.baseSize);
      
      // Calculate size with easing for smooth transitions
      // Size increases as object gets closer
      const sizeProgress = 1 - Math.max(0, Math.min(1, z / initialZ));
      const sizeFactor = minSize + (maxSize - minSize) * easeOutCubic(sizeProgress);
      
      // Set fixed circle dimensions - maintain perfect circle
      const circleSize = Math.max(minSize, Math.min(maxSize, sizeFactor));
      textElement.style.width = `${circleSize}px`;
      textElement.style.height = `${circleSize}px`;
      
      // Font size calculation - based on circle size with more conservative sizing
      // Smaller font for longer texts and account for increased padding
      const textLength = textElement.innerText.length;
      const fontScale = Math.min(1, 25 / Math.max(25, textLength));
      
      // Further reduce the size factor to account for increased padding
      // This ensures text stays well within the orb's boundaries with a comfortable margin
      const fontSize = Math.max(10, circleSize * 0.15 * fontScale);
      textElement.style.fontSize = `${fontSize}px`;
      
      // Calculate position based on progress
      // Objects follow a trajectory toward the center with slight drift
      const positionEasing = t => 1 - Math.pow(1 - t, 2.5); // Custom easing for position
      const positionProgress = positionEasing(progress);
      
      // Gradual movement toward center
      const currentX = initialX * (1 - positionProgress * 0.9); // 90% toward center
      const currentY = initialY * (1 - positionProgress * 0.9); // 90% toward center
      
      // Apply position with scale for perspective
      const posX = currentX * scale + screenCenterX;
      const posY = currentY * scale + screenCenterY;
      
      // Apply position
      textElement.style.left = `${posX}px`;
      textElement.style.top = `${posY}px`;
      
      // Fire effect intensity based on proximity
      const fireIntensity = Math.min(1, Math.max(0.2, easeOutCubic(sizeProgress)));
      
      // Fire glow increases as object gets closer
      const glowSize = 10 + 10 * fireIntensity;
      textElement.style.textShadow = `
        0 0 4px rgba(255, 255, 255, 0.8),
        0 0 ${glowSize * 0.6}px rgba(255, 220, 150, 0.8),
        0 0 ${glowSize}px rgba(255, 130, 50, 0.6),
        0 0 ${glowSize * 1.5}px rgba(255, 50, 0, 0.4)
      `;
      
      // Very subtle background glow that intensifies with proximity
      textElement.style.background = `radial-gradient(
        circle, 
        rgba(255,120,0,${0.1 * fireIntensity}) 0%, 
        rgba(255,60,0,${0.07 * fireIntensity}) 40%, 
        rgba(0,0,0,0) 70%
      )`;
      
      // More subtle border
      textElement.style.border = `1px solid rgba(255, 100, 0, ${0.15 + 0.2 * fireIntensity})`;
      
      // Opacity follows a bell curve - fade in, stay visible, fade out
      let opacity = 1;
      if (progress < 0.15) {
        // Fade in at the start
        opacity = progress / 0.15;
      } else if (progress > 0.85) {
        // Fade out at the end
        opacity = (1 - progress) / 0.15;
      }
      textElement.style.opacity = Math.max(0, Math.min(1, opacity));
      
      // Smooth rotation based on position and time
      // Assign consistent rotation values if not already set
      if (!textElement.dataset.rotationSet) {
        // Initial rotation based on position but constrained
        const baseRotX = (initialY / window.innerHeight) * 15; // -7.5 to 7.5 degrees
        const baseRotY = -(initialX / window.innerWidth) * 15; // -7.5 to 7.5 degrees
        
        // Store these values
        textElement.dataset.baseRotX = baseRotX.toFixed(2);
        textElement.dataset.baseRotY = baseRotY.toFixed(2);
        
        // Assign consistent wobble values
        textElement.dataset.wobbleFreqX = (0.5 + Math.random() * 0.3).toFixed(2); // Slower wobble
        textElement.dataset.wobbleFreqY = (0.4 + Math.random() * 0.3).toFixed(2); // Slower wobble
        textElement.dataset.wobbleAmpX = (2 + Math.random() * 2).toFixed(2); // Small amplitude
        textElement.dataset.wobbleAmpY = (2 + Math.random() * 2).toFixed(2); // Small amplitude
        textElement.dataset.rotationSet = "true";
      }
      
      // Get stored rotation values
      const baseRotX = parseFloat(textElement.dataset.baseRotX);
      const baseRotY = parseFloat(textElement.dataset.baseRotY);
      const wobbleFreqX = parseFloat(textElement.dataset.wobbleFreqX); 
      const wobbleFreqY = parseFloat(textElement.dataset.wobbleFreqY);
      const wobbleAmpX = parseFloat(textElement.dataset.wobbleAmpX);
      const wobbleAmpY = parseFloat(textElement.dataset.wobbleAmpY);
      
      // Calculate gentle wobble that diminishes as object gets closer
      const wobbleReducer = Math.max(0.2, 1 - positionProgress); // Reduce wobble as it gets closer
      const time = now / 1000; // Current time in seconds
      const wobbleX = Math.sin(time * wobbleFreqX) * wobbleAmpX * wobbleReducer;
      const wobbleY = Math.cos(time * wobbleFreqY) * wobbleAmpY * wobbleReducer;
      
      // Apply rotation with wobble
      const rotateX = baseRotX + wobbleX;
      const rotateY = baseRotY + wobbleY;
      
      // Apply transform
      textElement.style.transform = `
        rotateX(${rotateX}deg) 
        rotateY(${rotateY}deg)
      `;
    }
    
    // Animation loop
    function animate() {
      // Update stars
      document.querySelectorAll('.star').forEach(star => {
        // Move forward (decrease z)
        star.dataset.z -= parseFloat(star.dataset.speed);
        
        // If star goes out of view, reset it
        if (star.dataset.z <= 0) {
          star.dataset.z = maxDepth;
          star.dataset.x = Math.random() * window.innerWidth - window.innerWidth / 2;
          star.dataset.y = Math.random() * window.innerHeight - window.innerHeight / 2;
        }
        
        updateStarPosition(star);
      });
      
      // Update planets
      document.querySelectorAll('.planet').forEach(planet => {
        // Move forward (decrease z)
        planet.dataset.z -= parseFloat(planet.dataset.speed);
        
        // If planet goes out of view, reset it
        if (planet.dataset.z <= 0) {
          planet.dataset.z = maxDepth + Math.random() * maxDepth;
          planet.dataset.x = (Math.random() * 2 - 1) * window.innerWidth;
          planet.dataset.y = (Math.random() * 2 - 1) * window.innerHeight;
          
          // Change color
          const hue = Math.random() * 360;
          const saturation = 70 + Math.random() * 30;
          const lightness = 20 + Math.random() * 30;
          planet.style.backgroundColor = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }
        
        updatePlanetPosition(planet);
      });
      
      // Update flying text
      document.querySelectorAll('.flying-text').forEach(textElement => {
        // Move forward (decrease z) very fast
        textElement.dataset.z -= parseFloat(textElement.dataset.speed);
        
        // Update position
        updateFlyingTextPosition(textElement);
      });
      
      requestAnimationFrame(animate);
    }
    
    // Start animation
    animate();
    
    // Handle window resize
    window.addEventListener('resize', () => {
      // Recalculate positions based on new window size
      document.querySelectorAll('.star, .planet').forEach(element => {
        if (element.classList.contains('star')) {
          updateStarPosition(element);
        } else {
          updatePlanetPosition(element);
        }
      });
    });
  </script>
</body>
</html>